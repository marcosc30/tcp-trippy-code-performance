# ReadMe

## Design Choices

### How you build your abstractions for the IP layer and interfaces (What data structures do you have? How do your vhost and vrouter programs interact with your shared IP stack code?)



### How you use threads/goroutines
In general, we use threads for various listening/checking tasks for both the routers and host. For hosts, the only go routines used apart from the main thread (that handes REPL for both hosts and routers) is one for each interface to handle listening for incoming packets. 

For routers, we also have a go routine for each interface to listen, but we also have one for sending periodic RIP updates and checking to the forwarding table (which is integrated with the RIP updates) to check for routes that have timed out. 

### The steps you will need to process IP packets

Given an interface receives a packet through UDP (technically on interface listen, we first check to make sure that interface isn't down before continuing to listen), we first unmarshal the packet using a function we made. Then we validate the packet (check the checksum and the TTL) and check if it is for us. If its destination matches one of our interfaces, we send it to the appropriate packet handler based on the packet's protocol (this is done with a function called HandlePacket and with registering protocol handlers in the vhost and vrouter programs). 

If it is not for us, we check if one of the interface netmasks contains the packet destination, in which case the destination is on a directly connected subnet, so we can send the packet directly to the destination IP (we had a function that does this, which itself does it through the interface neighbors). If this is not the case, we apply forwarding logic to it using a function called nextHop (which uses the forwarding table to decide the next hop) and use sendPacket but to send it to the next hop. 

### Other Design Choices


### Found bugs:
- There is a minor bug, since we do the check for an interface being down at the start of each loop in interface listen, since the interface holds while waiting for UDP packets, if the interface is downed while waiting for a UDP packet while in readFromUDP, it will still receive one more packet. I tried fixing this with a read timeout, but this would make it so when the interface was upped, it would suddenly receive a bunch of packets at once. 